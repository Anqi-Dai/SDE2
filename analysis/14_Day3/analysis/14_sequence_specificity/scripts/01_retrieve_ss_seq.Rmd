---
title: "Retrieve sequences near splice site"
author: "Anqi Dai"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    code_folding: hide 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = F, warning = F)
library(tidyverse)
library(ggpubr)
library(kableExtra)

```

```{r}
# get the sig and non sig separatly for two comparisons.

data_path <- '../../05_IRfinder/data/rawIRfinderResult/'
fns <- list.files(data_path, pattern = 'txt', full.names = T)

sig <- fns %>%
  map(~ read_tsv(.,comment = '#',col_names = T)  %>%
        mutate(Start = Start + 1) %>%
        mutate(locus = paste(Chr,paste(Start, End, sep = '-'), sep = ':' ) ) %>%
        rename_all(funs(stringr::str_replace_all(., '-', '_') )) %>%
        separate(names(.)[4], into = c('Symbol', 'GeneID', 'Category'), sep = '/') %>%
        mutate(GeneID = str_replace_all(string = GeneID, pattern = '\\..*$', replacement = ''),
               padj = p.adjust(p_diff, method = 'BH')) %>%
        filter(! Category == 'known-exon') %>%
        filter(A_IRok != 'MinorIsoform' &  B_IRok != 'MinorIsoform' ) %>%
        filter(padj < 0.05) 
      )

non_Sig <- fns %>%
  map(~ read_tsv(.,comment = '#',col_names = T)  %>%
        mutate(Start = Start + 1) %>%
        mutate(locus = paste(Chr,paste(Start, End, sep = '-'), sep = ':' ) ) %>%
        rename_all(funs(stringr::str_replace_all(., '-', '_') )) %>%
        separate(names(.)[4], into = c('Symbol', 'GeneID', 'Category'), sep = '/') %>%
        mutate(GeneID = str_replace_all(string = GeneID, pattern = '\\..*$', replacement = ''),
               padj = p.adjust(p_diff, method = 'BH')) %>%
        filter(! Category == 'known-exon') %>%
        filter(A_IRok != 'MinorIsoform' &  B_IRok != 'MinorIsoform' ) %>%
        filter(padj >= 0.05) 
      )
```
 
```{r}
# now the sig locus is the intersection
# and the nonSig is still the intersection
sig_locus <- intersect(sig[[1]]$locus, sig[[2]]$locus)

non_Sig_locus <- intersect(non_Sig[[1]]$locus, non_Sig[[2]]$locus)
 
tibble(sig_locus = length(sig_locus),
       non_Sig_locus = length(non_Sig_locus)) 
```
  
```{r}
# getting the length of the locus
sig_df <-  sig[[1]] %>%
  filter(locus %in% sig_locus) %>%
  dplyr::select(chr = Chr, start = Start, end = End, direction = Direction)  %>%
  mutate(RIlen = end - start,
         catetory = 'Sig') %>%
  arrange(RIlen)  

non_Sig_df <-  non_Sig[[1]] %>%
  filter(locus %in% non_Sig_locus) %>%
  dplyr::select(chr = Chr, start = Start, end = End, direction = Direction)  %>%
  mutate(RIlen = end - start,
         catetory = 'Non-sig') %>%
  arrange(RIlen)  
 
```

```{r}
# bin them into every smaller per bin and count how many in them 

sig_bin <- table(cut_interval(sig_df$RIlen, length=50)) %>%
  as.data.frame %>% 
  select(interval = Var1,
         sig = Freq)
  
non_sig_bin <- table(cut_interval(non_Sig_df$RIlen, length=50)) %>%
  as.data.frame %>% 
  select(interval = Var1,
         non_sig = Freq)

# the way I decided how many to select for each interval
all <- sig_bin %>%
  left_join(non_sig_bin, by = 'interval') %>%
  rowwise() %>%
  mutate(numSelect = min(non_sig, sig)) %>%
  filter(!is.na(numSelect))

# if I can use a df as input for every row
input_all <- all %>%
  mutate(interval = str_replace_all(string = interval, pattern = "]$",replacement = '')) %>%
  mutate(interval = str_replace_all(string = interval, pattern = "\\(|\\[",replacement = '')) %>%
  separate(interval, into = c('lower','upper'), convert = T) %>%
  dplyr::select(-non_sig, -sig) 

```

```{r}
# a function that takes a interval and return the rows that meet that interval

records_in_interval_sig <- function(lower, upper,numSelect) {
  ret = sig_df %>%
    filter(RIlen > lower & RIlen <= upper) %>%
    sample_n(numSelect)
  return(ret)
} 

res_sig <- pmap_dfr(input_all, function(lower, upper, numSelect){
  records_in_interval_sig(lower, upper, numSelect)
})


# for non-sig
records_in_interval_non_sig <- function(lower, upper,numSelect) {
  ret = non_Sig_df %>%
    filter(RIlen > lower & RIlen <= upper) %>%
    sample_n(numSelect)
  return(ret)
} 

res_non_sig <- pmap_dfr(input_all, function(lower, upper, numSelect){
  records_in_interval_non_sig(lower, upper, numSelect)
})

```

```{r}
# from here I get the sequences in two groups that have a length < certain threshold and output the df
out <- bind_rows(
  res_sig %>% 
    filter(RIlen < 100),
  res_non_sig %>% 
    filter(RIlen < 100)
)

out300 <- bind_rows(
  res_sig %>% 
    filter(RIlen < 300),
  res_non_sig %>% 
    filter(RIlen < 300)
)  

out %>% 
  write_csv('../output/two_groups_seq_info_len_100.csv')

out300 %>% 
  write_csv('../output/two_groups_seq_info_len_300.csv')

table(out300$catetory) 
```


# getting the sequences from non-AS-short(nashort) 

```{r}
# the subsets that are non-as-short
nashort <- read_csv('../../05_IRfinder/data/03_non_AS_seq_info.csv')  %>% 
  filter(intronLen < 358) %>% 
  dplyr::select(direction = strand, locus, RIlen = intronLen, category) %>% 
  separate(col = locus, into = c('chr','coord'), sep = ':', remove = T) %>%
  separate(coord, into = c('start','end'), sep = '-', convert = T)

# then a function to get a sample size which is the same number to the sig and non-sig counterpart sequences under a len threshold which is the same to the other two too
get_non_AS_locus <- function(len){
  numSelect = res_sig %>% 
    filter(RIlen < len) %>% 
    nrow
  
  ret = nashort %>%
    filter(RIlen < len) %>%
    sample_n(numSelect)
  
  ret %>% 
    write_csv(str_glue('../output/two_groups_seq_info_len_{len}_non_AS.csv'))
}


get_non_AS_locus(300)
```
